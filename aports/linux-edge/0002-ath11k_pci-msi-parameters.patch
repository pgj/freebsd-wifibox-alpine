From: Jose Ignacio Tornos Martinez <jtornosm@redhat.com>
Subject: [PATCH V2] wifi: ath11k: workaround to use VMs
Date: Fri, 22 Mar 2024 11:49:12 +0100

Currently, this driver is not working when the device is handled in a
Virtual Machine (PCI pass-through), as it was already reported here:
https://lore.kernel.org/all/fc6bd06f-d52b-4dee-ab1b-4bb845cc0b95@quicinc.com/T/
Baochen Qiang focused the problem and described how to have it working
for a specific real MSI vector from host that needs to be used in VM too.
And this value, as it was commented, can change.

The problem seems complex to me and I don't know if there is any easy way
to solve it (with no more information, not hardware/firmware related help
or VMM action).
Meanwhile and using the information from Baochen Qiang, since the use of
VMs is very interesting for testing procedures, I would like to include
this workaround that consists on adding two parameters to pass the real MSI
vector address and data from host to the VM.
In that way, checking the 'lscpi' command output from host, it could be
handled manually or with some user tool in order to have the VM with the
driver working.
Of course, if the workaround is not used, that is if MSI vector address
parameter is not configured (zero value and default), we will have the same
behavior as always.

Signed-off-by: Jose Ignacio Tornos Martinez <jtornosm@redhat.com>
---
 drivers/net/wireless/ath/ath11k/pci.c | 24 ++++++++++++++++++++++++
 1 file changed, 24 insertions(+)

diff --git a/drivers/net/wireless/ath/ath11k/pci.c b/drivers/net/wireless/ath/ath11k/pci.c
index be9d2c69cc41..4c84208dcf5d 100644
--- a/drivers/net/wireless/ath/ath11k/pci.c
+++ b/drivers/net/wireless/ath/ath11k/pci.c
@@ -31,6 +31,15 @@
 
 #define TCSR_SOC_HW_SUB_VER	0x1910010
 
+static ulong ath11k_host_msi_vector_addr = 0;
+module_param_named(host_msi_vector_addr, ath11k_host_msi_vector_addr, ulong, 0644);
+MODULE_PARM_DESC(host_msi_vector_addr,
+		 "Workaround to configure the MSI vector address that is used from host in order to be used in VM");
+static uint ath11k_host_msi_vector_data = 0;
+module_param_named(host_msi_vector_data, ath11k_host_msi_vector_data, uint, 0644);
+MODULE_PARM_DESC(host_msi_vector_data,
+		 "Workaround to configure the MSI vector data that is used from host in order to be used in VM");
+
 static const struct pci_device_id ath11k_pci_id_table[] = {
 	{ PCI_VDEVICE(QCOM, QCA6390_DEVICE_ID) },
 	{ PCI_VDEVICE(QCOM, WCN6855_DEVICE_ID) },
@@ -443,6 +452,18 @@ static int ath11k_pci_alloc_msi(struct ath11k_pci *ab_pci)
 
 	ath11k_pci_msi_disable(ab_pci);
 
+	if (ath11k_host_msi_vector_addr) {
+		ab_pci->ab->pci.msi.ep_base_data = ath11k_host_msi_vector_data;
+		ab->pci.msi.addr_hi = (u32)(ath11k_host_msi_vector_addr >> 32);
+		ab->pci.msi.addr_lo = (u32)(ath11k_host_msi_vector_addr & 0xffffffff);
+
+		ath11k_dbg(ab, ATH11K_DBG_PCI, "msi addr hi 0x%x lo 0x%x base data is %d\n",
+			   ab->pci.msi.addr_hi,
+			   ab->pci.msi.addr_lo,
+			   ab->pci.msi.ep_base_data);
+		return 0;
+	}
+
 	msi_desc = irq_get_msi_desc(ab_pci->pdev->irq);
 	if (!msi_desc) {
 		ath11k_err(ab, "msi_desc is NULL!\n");
@@ -482,6 +503,9 @@ static int ath11k_pci_config_msi_data(struct ath11k_pci *ab_pci)
 {
 	struct msi_desc *msi_desc;
 
+	if (ath11k_host_msi_vector_addr)
+		return 0;
+
 	msi_desc = irq_get_msi_desc(ab_pci->pdev->irq);
 	if (!msi_desc) {
 		ath11k_err(ab_pci->ab, "msi_desc is NULL!\n");
-- 
2.44.0


